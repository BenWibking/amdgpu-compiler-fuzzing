# Spill dominance violation in AMDGPU greedy RA (gfx942)

## Summary

The AMDGPU greedy register allocator emits spill restores for %stack.163, %stack.166, and %stack.167 in blocks `bb.84`, `bb.108`, and `bb.116` without any dominating spill save. There are valid control-flow paths to those blocks that bypass all saves for these slots, so the restores can read uninitialized stack values.

This was reproduced from a fuzzed kernel derived from the Pele corpus.

## Environment

- AMD LLVM: 19.0.0git (ROCm 6.4.4)
- Target: amdgcn-amd-amdhsa
- mcpu: gfx942
- Pass: greedy

`llc --version` output:

```
AMD LLVM version 19.0.0git
  Optimized build.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: westmere
```

## Reproducer

Input IR (generated by the fuzzer):

```
spill_fuzz_out/kernel-pc_cmpflx_launch-a7d5b88a0dde5efe7b96045874e05330cd93917d.vgpr20.sgpr108.ll
```

Command:

```
/opt/rocm-6.4.4/lib/llvm/bin/llc \
  -mtriple=amdgcn-amd-amdhsa \
  -mcpu=gfx942 \
  -stop-after=greedy \
  -print-after=greedy \
  -o /dev/null \
  spill_fuzz_out/kernel-pc_cmpflx_launch-a7d5b88a0dde5efe7b96045874e05330cd93917d.vgpr20.sgpr108.ll \
  > /tmp/llc.out 2> /tmp/llc.err
```

## Automated check script

The repository includes a script that verifies zero spill-dominance issues on
the original kernel, then reproduces the spill-dominance issues with the
mutated IR:

```
./tools/spill_fuzz/check_spill_dominance_repro.sh \
  --llc /opt/rocm-6.4.4/lib/llvm/bin/llc \
  --mcpu gfx942 \
  --input kernels/pele/kernel-pc_cmpflx_launch-a7d5b88a0dde5efe7b96045874e05330cd93917d.ll \
  --vgpr 20 \
  --sgpr 108
```

## GPU oracle (optional)

To run the kernel on a real GPU with deterministic, valid inputs, use the HIP
runner and the provided input spec. This compares outputs between a
high-register reference build and the fuzzed build.

From repo root:

```
SPILL_FUZZ_LLC=/opt/rocm-6.4.4/lib/llvm/bin/llc \
SPILL_FUZZ_LLD=/opt/rocm-6.4.4/lib/llvm/bin/ld.lld \
SPILL_FUZZ_LLVM_READOBJ=/opt/rocm-6.4.4/lib/llvm/bin/llvm-readobj \
SPILL_FUZZ_GPU_STRICT=1 \
./tools/spill_fuzz/repro_spill_dominance_gpu.sh
```

Notes:
- The script uses `tools/spill_fuzz/input_specs/pc_cmpflx_launch.json` to set
  safe scalar values, buffer sizes, and launch dims for this kernel.
- A non-zero exit or "output mismatch" indicates a GPU-visible divergence.

## Evidence

### Spill saves (only in `bb.79`, `bb.81`, `bb.83`)

From `/tmp/llc.err`:

```
512372B  SI_SPILL_S32_SAVE %52383:sreg_32_xm0_xexec, %stack.163
512424B  SI_SPILL_S32_SAVE %52400:sreg_32_xm0_xexec, %stack.166
512440B  SI_SPILL_S32_SAVE %52410:sreg_32_xm0_xexec, %stack.167

512984B  SI_SPILL_S32_SAVE %52384:sreg_32_xm0_xexec, %stack.163
513080B  SI_SPILL_S32_SAVE %52411:sreg_32_xm0_xexec, %stack.167
513096B  SI_SPILL_S32_SAVE %52401:sreg_32_xm0_xexec, %stack.166

513640B  SI_SPILL_S32_SAVE %52402:sreg_32_xm0_xexec, %stack.166
513720B  SI_SPILL_S32_SAVE %52385:sreg_32_xm0_xexec, %stack.163
513736B  SI_SPILL_S32_SAVE %52412:sreg_32_xm0_xexec, %stack.167
```

These saves appear only in blocks `bb.79`, `bb.81`, and `bb.83`.

### Spill restores (in `bb.84`, `bb.108`, `bb.116`)

From `/tmp/llc.err`:

```
527864B  %52379:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.163
528248B  %52396:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.166
528312B  %52406:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.167

779512B  %52413:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.167
779752B  %52386:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.163
780216B  %52403:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.166

862584B  %52404:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.166
862712B  %52414:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.167
862840B  %52387:sreg_32_xm0_xexec = SI_SPILL_S32_RESTORE %stack.163
```

### CFG path without saves to `bb.84`

From `/tmp/llc.err` near the relevant blocks:

```
bb.78.Flow256:
  successors: %bb.79, %bb.84

bb.79:
  successors: %bb.84

bb.84:
  ; predecessors: %bb.78, %bb.79
```

A valid path to `bb.84` that bypasses all saves is:

```
bb.74 -> bb.75 -> bb.76 -> bb.80 -> bb.82 -> bb.78 -> bb.84
```

CFG sketch (subset of the region):

```
bb.74
  |
bb.75
  |
bb.76
  |
bb.80
  |
bb.82
  |
bb.78 ----> bb.79
  |          |
  +--------> bb.84
```

This path avoids `bb.79`, `bb.81`, and `bb.83`, so no save of %stack.163/166/167 dominates the restores in `bb.84`.

### Similar issue for `bb.108` and `bb.116`

`bb.108` and `bb.116` are in later regions with their own predecessors, but the only saves for these slots remain in `bb.79/81/83`, which do not dominate those later blocks.

## Expected vs Observed

- **Expected:** Each spill restore should be dominated by a corresponding spill save on all control-flow paths.
- **Observed:** Restores of %stack.163/166/167 in `bb.84`, `bb.108`, and `bb.116` are reachable without any dominating save.

## Notes

This is no longer a parser false positive. The CFG naming normalization in the fuzzer now maps successors to the correct block IDs, and the dominance check still reports these restores. The MIR dump shows actual restore instructions in blocks that are reachable via save-free paths.
